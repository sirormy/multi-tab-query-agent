# 任务规划 (`speckit.md`)
```markdown
# [Goal] 构建一个支持多 Tab 独立会话的 Electron 应用

**Objective**: 创建一个桌面应用，允许用户在多个 Tab 中分别登录腾讯元宝、DeepSeek 等服务，并通过一个统一的输入框将问题同步广播到所有打开的 Tab 中进行查询。

**Tech Stack**: Electron, React, TypeScript, TailwindCSS

---

## [Phase 1] 项目初始化与环境配置

**Description**: 使用 Antigravity 内置的脚手架初始化一个标准的 Electron + React + TypeScript 项目，并配置好所需的基础环境和依赖。

- **[Task]** 使用 `Electron + React + TypeScript` 模板初始化新项目，项目名称为 `multi-tab-query-agent`。
- **[Task]** 安装额外的依赖：`tailwindcss`, `postcss`, `autoprefixer`。
- **[Task]** 初始化 TailwindCSS 配置文件：`tailwind.config.js` 和 `postcss.config.js`。
- **[Task]** 配置 `tailwind.config.js`，确保 `content` 字段包含所有 `src/renderer` 下的 `.(js|ts|jsx|tsx)` 文件。
- **[Task]** 在主 CSS 文件 (`src/renderer/src/index.css`) 中引入 TailwindCSS 的基础指令。

---

## [Phase 2] 主进程逻辑实现 (main.ts)

**Description**: 编写主进程代码，负责管理应用的生命周期、窗口、`BrowserView` 实例以及进程间通信。

- **[Task]** 在 `src/main/index.ts` 中，实现主窗口 (`BrowserWindow`) 的创建和加载。
- **[Task]** 设计一个数据结构（如 `Map`）来存储和管理所有 `BrowserView` 实例。
- **[Task]** 编写一个函数 `createTab(url)`，用于：
    1.  创建一个独立的 `session`，使用 `session.fromPartition` 确保会话隔离。
    2.  基于此 `session` 创建一个新的 `BrowserView` 实例。
    3.  为 `BrowserView` 设置 `preload` 脚本路径。
    4.  将 `BrowserView` 添加到主窗口并加载指定的 `url`。
    5.  将其存储到管理结构中。
- **[Task]** 编写一个函数 `switchTab(tabId)`，用于显示指定的 `BrowserView` 并隐藏其他的。
- **[Task]** 设置 IPC 监听器 (`ipcMain.handle`)：
    - `tabs:create`: 接收 URL，调用 `createTab` 函数，并返回新 Tab 的 ID。
    - `tabs:switch`: 接收 Tab ID，调用 `switchTab` 函数。
    - `question:broadcast`: 接收问题字符串，遍历所有 `BrowserView` 实例，并通过 `webContents.send('question:sync', question)` 将问题广播出去。

---

## [Phase 3] 预加载脚本实现 (preload.ts)

**Description**: 编写预加载脚本，作为主进程与渲染进程（Web 页面）之间的安全桥梁，负责接收广播的问题并与页面 DOM 交互。

- **[Task]** 在 `src/preload/index.ts` 中，使用 `contextBridge` 暴露一个安全的 API 给渲染进程。
- **[Task]** 在暴露的 API 中，包含一个 `onQuestionSync` 方法，该方法接收一个回调函数，并使用 `ipcRenderer.on('question:sync', callback)` 来监听主进程的广播。
- **[Task]** 在 `onQuestionSync` 的回调中，编写 DOM 操作逻辑：
    1.  根据 `window.location.href` 判断当前是哪个网站（腾讯元宝、DeepSeek 等）。
    2.  为每个网站定义精确的 DOM 选择器（`inputSelector`, `buttonSelector`）。
    3.  找到输入框元素，并以模拟用户输入的方式填入问题（以触发框架的事件监听）。
    4.  找到发送按钮元素，并触发其 `click` 事件。

---

## [Phase 4] 渲染器 UI 实现 (React Components)

**Description**: 构建应用的前端界面，包括 Tab 栏、地址栏和统一的问题输入框。

- **[Task]** 在 `src/renderer/src/App.tsx` 中，设计应用的主体布局。
- **[Task]** 创建 `TabList` 组件：
    - 维护一个 `tabs` 状态数组，包含 `id` 和 `title`。
    - 渲染 Tab 列表，并提供一个“+”按钮用于新增 Tab。
    - 点击“+”时，调用主进程的 `tabs:create` IPC 通道。
    - 点击某个 Tab 时，调用 `tabs:switch`。
- **[Task]** 创建 `QueryInput` 组件：
    - 包含一个 `input` 和一个“发送”按钮。
    - 点击按钮时，调用主进程的 `question:broadcast` IPC 通道，将输入框内容发送出去。
- **[Task]** 使用 TailwindCSS 为所有组件添加样式，确保界面美观易用。

---

## [Phase 5] 集成、调试与验证

**Description**: 确保所有部分正确集成，并运行应用进行端到端的功能验证。

- **[Task]** 检查 `electron.vite.config.ts` 配置文件，确保 `main`, `preload`, `renderer` 的入口都已正确配置。
- **[Task]** 运行 `dev` 命令启动应用。
- **[Verification]** 验证“+”按钮可以成功创建新的 Tab 并加载默认页面。
- **[Verification]** 在多个 Tab 中分别手动登录不同的账号，验证会话是隔离的（切换 Tab 不会导致账号登出）。
- **[Verification]** 在统一输入框中输入问题并发送，验证所有 Tab 页内的输入框都被自动填充并执行了查询。
- **[Verification]** 调试 `preload.ts` 中的 DOM 选择器，确保其在目标网站改版后依然能正常工作。
```

## 3. 技术实现深度解析

本节为开发人员提供 SpecKit 任务规划背后的详细技术解析，解释了架构选择的原因和关键代码的实现逻辑。AI Agent 会根据 SpecKit 生成代码，而本节内容能帮助你更好地理解、调试和扩展这些代码。

### 3.1. 主进程架构 (`main.ts`)

主进程是应用的核心，其关键职责是**创建和管理 `BrowserView` 实例**，并确保它们之间的**会话完全隔离**。

- **`BrowserView` vs. `iframe`**: 我们选择 `BrowserView` 而不是 `iframe`，因为 `BrowserView` 是一个独立的浏览器上下文，可以拥有自己的 `session`。而 `iframe` 会共享其父页面的 `session`，无法实现真正的账号隔离。

- **会话隔离 (`session.fromPartition`)**: 这是实现多账号登录的“魔法”。通过 `session.fromPartition('persist:some-unique-name')`，我们为每个 `BrowserView` 创建了一个持久化的、独立的会话。这意味着每个 Tab 的 Cookie、LocalStorage 等数据都存储在不同的分区中，互不干扰。

**详细代码示例 (`src/main/index.ts`)**:

```typescript
// src/main/index.ts
import { app, BrowserWindow, BrowserView, session, ipcMain } from 'electron';
import { join } from 'path';

// ... (窗口创建逻辑)

const views = new Map<string, BrowserView>();
let mainWindow: BrowserWindow;

async function createWindow() {
  // ...
  // IPC Handlers
  ipcMain.handle('tabs:create', async (event, url: string) => {
    const tabId = `tab-${Date.now()}`;
    const tabSession = session.fromPartition(`persist:${tabId}`);

    const view = new BrowserView({
      webPreferences: {
        session: tabSession,
        preload: join(__dirname, '../preload/index.js'),
        sandbox: false // 根据实际需求调整
      }
    });

    mainWindow.addBrowserView(view);
    // 初始位置和大小设置，后续会由渲染器调整
    view.setBounds({ x: 0, y: 40, width: mainWindow.getBounds().width, height: mainWindow.getBounds().height - 40 });
    view.setAutoResize({ width: true, height: true });
    await view.webContents.loadURL(url);

    views.set(tabId, view);
    return tabId;
  });

  ipcMain.handle('question:broadcast', (event, question: string) => {
    for (const view of views.values()) {
      view.webContents.send('question:sync', question);
    }
  });
}
```

### 3.2. 预加载脚本的桥梁作用 (`preload.ts`)

预加载脚本是 Electron 的一大安全特性，也是我们实现页面交互的关键。它运行在一个特权环境中，既能访问 Node.js 的部分 API（如 `ipcRenderer`），也能访问页面的 `window` 和 `document` 对象。

- **`contextBridge`**: 我们使用 `contextBridge` 来安全地将主进程的功能暴露给渲染进程（这里指 `BrowserView` 中加载的 Web 页面），而不是直接污染 `window` 对象。这可以防止外部网页调用任意 Electron API。

- **与现代前端框架交互**: 腾讯元宝、DeepSeek 等现代 Web 应用大多使用 React 或 Vue 构建。直接修改 `input.value` 可能无法触发框架的状态更新。因此，我们需要模拟真实的用户输入事件，如下方代码所示。

**详细代码示例 (`src/preload/index.ts`)**:

```typescript
// src/preload/index.ts
import { contextBridge, ipcRenderer } from 'electron';

contextBridge.exposeInMainWorld('electronAPI', {
  onQuestionSync: (callback) => ipcRenderer.on('question:sync', callback)
});

ipcRenderer.on('question:sync', (event, question: string) => {
  console.log('Received question:', question);
  // 此处应有更复杂的逻辑来注入问题
  const url = window.location.href;
  let inputSelector: string | null = null;
  let buttonSelector: string | null = null;

  if (url.includes('yuanbao.tencent.com')) {
    inputSelector = 'textarea.ProseMirror'; // 示例，需用开发者工具确认
    buttonSelector = 'button[data-testid="send-button"]'; // 示例
  } else if (url.includes('deepseek.com')) {
    inputSelector = 'textarea[placeholder*="Ask me anything"]'; // 示例
    buttonSelector = 'button.absolute'; // 示例
  }

  if (!inputSelector || !buttonSelector) return;

  const inputElement = document.querySelector<HTMLTextAreaElement>(inputSelector);
  const buttonElement = document.querySelector<HTMLButtonElement>(buttonSelector);

  if (inputElement && buttonElement) {
    // 模拟 React/Vue 的输入事件
    const nativeInputValueSetter = Object.getOwnPropertyDescriptor(
      window.HTMLTextAreaElement.prototype,
      'value'
    ).set;
    nativeInputValueSetter.call(inputElement, question);
    inputElement.dispatchEvent(new Event('input', { bubbles: true }));

    // 延迟点击，等待框架状态更新
    setTimeout(() => {
      buttonElement.click();
    }, 100);
  }
});
```

### 3.3. 渲染器 UI (`App.tsx`)

主渲染器进程负责应用的“外壳”。它本身不加载任何外部网页，只提供 Tab 管理和统一查询的 UI。

**详细代码示例 (`src/renderer/src/App.tsx`)**:

```tsx
// src/renderer/src/App.tsx
import React, { useState } from 'react';

interface Tab {
  id: string;
  title: string;
}

function App() {
  const [tabs, setTabs] = useState<Tab[]>([]);
  const [activeTab, setActiveTab] = useState<string | null>(null);
  const [question, setQuestion] = useState('');

  const addNewTab = async () => {
    const defaultUrl = 'https://yuanbao.tencent.com/';
    const tabId = await window.electron.ipcRenderer.invoke('tabs:create', defaultUrl);
    setTabs([...tabs, { id: tabId, title: `Tab ${tabs.length + 1}` }]);
    setActiveTab(tabId);
  };

  const broadcastQuestion = () => {
    window.electron.ipcRenderer.invoke('question:broadcast', question);
  };

  return (
    <div className="flex flex-col h-screen">
      {/* Tab Bar */}
      <div className="flex border-b">
        {tabs.map(tab => (
          <div key={tab.id} className={`p-2 cursor-pointer ${activeTab === tab.id ? 'bg-gray-200' : ''}`}>
            {tab.title}
          </div>
        ))}
        <button onClick={addNewTab} className="p-2">+</button>
      </div>

      {/* Query Input */}
      <div className="p-2 flex border-t">
        <input
          type="text"
          value={question}
          onChange={(e) => setQuestion(e.target.value)}
          className="flex-grow border p-1"
          placeholder="向所有 Tab 提问..."
        />
        <button onClick={broadcastQuestion} className="ml-2 p-1 bg-blue-500 text-white">
          广播
        </button>
      </div>

      {/* BrowserView will be positioned here by the main process */}
    </div>
  );
}

export default App;
```